# JDK Internal

Cover JDK java core API topics.

# JDK, JRE and JVM

Here is information about JDK, JRE, and JVM, including the internals of JVM:

1. Java Development Kit (JDK):
   The JDK is a software development environment used for developing Java applications and applets. It includes the Java
   Runtime Environment (JRE), an interpreter/loader (java), a compiler (javac), an archiver (jar), a documentation
   generator (javadoc), and other development tools. Developers use the JDK to write, compile, debug, and run Java
   programs.

2. Java Runtime Environment (JRE):
   The JRE is a software package that provides the minimum environment required to run a Java application. It includes
   the Java Virtual Machine (JVM) and Java libraries (like rt.jar), which contain pre-written code for common tasks.
   End-users who only need to run Java applications typically install the JRE.

3. Java Virtual Machine (JVM):
   The JVM is an abstract machine that provides the runtime environment in which Java bytecode is executed. It acts as
   an interpreter for Java bytecode, converting it into machine-specific code that the underlying operating system can
   understand and execute. The JVM is crucial for Java's "write once, run anywhere" capability, as it abstracts away the
   underlying hardware and operating system details.

# Classloader


***Classloader Subsystem:***

Responsible for loading, linking, and initializing class files.

***Loading***

Finds and loads the binary representation of a class or interface based on its fully qualified name.

***Linking***

Verifies the loaded class, prepares it for execution, and resolves symbolic references.

***Initialization***

Executes the static initializers of the class and initializes static fields to their default values.

Java ClassLoaders are a fundamental component of the Java Virtual Machine (JVM) responsible for dynamically loading Java
classes into memory at runtime. They enable the JVM to locate, load, and link class definitions from various sources,
such as the local file system, networks, or even dynamically generated bytecode.

How ClassLoaders Work:

Java ClassLoaders operate based on a delegation model, forming a hierarchical structure:

Bootstrap ClassLoader:

The top-level class loader, responsible for loading core Java API classes (e.g., java.lang.*) from the rt.jar (or
equivalent) in the Java runtime environment.

Extension ClassLoader:

Loads classes from the Java extensions directory (jre/lib/ext).

Application (System) ClassLoader:

Loads classes from the application's classpath, which is typically specified by the -classpath or -cp command-line
argument.

Custom ClassLoaders:

Developers can create their own custom class loaders to handle specific class loading requirements.
When a class needs to be loaded, the JVM requests it from the current class loader. Following the delegation model, the
class loader first delegates the request to its parent. This process continues up the hierarchy until the Bootstrap
ClassLoader. If a parent class loader successfully loads the class, it is returned. If not, the current class loader
attempts to find and load the class itself.

Creating Custom ClassLoaders:

You can create a custom class loader by extending the java.lang.ClassLoader class and overriding its findClass() method.
The findClass() method is where you define how your custom class loader locates and loads the raw bytes of a class.

Here's a basic example:

```java
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class CustomClassLoader extends ClassLoader {

    private String classPath;

    public CustomClassLoader(String classPath, ClassLoader parent) {
        super(parent);
        this.classPath = classPath;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            byte[] classBytes = loadClassData(name);
            return defineClass(name, classBytes, 0, classBytes.length);
        } catch (IOException e) {
            throw new ClassNotFoundException("Could not load class: " + name, e);
        }
    }

    private byte[] loadClassData(String name) throws IOException {
        String fileName = name.replace('.', '/') + ".class";
        Path filePath = Paths.get(classPath, fileName);
        return Files.readAllBytes(filePath);
    }

    public static void main(String[] args) throws Exception {
        // Assuming MyClass.class is in the "custom_classes" directory
        String customClassPath = "custom_classes";
        CustomClassLoader customLoader = new CustomClassLoader(customClassPath, ClassLoader.getSystemClassLoader());

        // Load and instantiate a class using the custom class loader
        Class<?> myClass = customLoader.loadClass("MyClass");
        Object instance = myClass.getDeclaredConstructor().newInstance();
        System.out.println("Loaded class: " + myClass.getName() + " with ClassLoader: " + myClass.getClassLoader());
    }
}
```

Custom ClassLoaders are useful for scenarios like:

Loading classes from non-standard locations (databases, networks, encrypted files).
Implementing plugin architectures where different plugins might have conflicting dependencies.
Dynamically loading and unloading classes at runtime.

# JDK Internals

***Memory Areas (Runtime Data Areas)***

These are created by the JVM during its execution to store data required for program execution.

***Method Area***

Stores class-level data, including static variables, method code, and constant pool.

***Heap***

Stores all objects and arrays created during program execution. This is where garbage collection primarily operates.

***Stack***

Each thread has its own private JVM stack, which stores local variables, partial results, and method calls (frames).

***PC Registers***

Each thread has a program counter register that stores the address of the currently executing JVM instruction.

***Native Method Stacks***

Used for native methods (methods written in languages other than Java, like C/C++).

***Execution Engine***

Responsible for executing the bytecode loaded by the classloader.

***Interpreter***

Reads and executes bytecode instructions one by one.

***Just-In-Time (JIT) Compiler***

Compiles frequently executed bytecode into native machine code during runtime to improve performance. It identifies "hot
spots" in the code and compiles them for faster execution.

***Garbage Collector (GC)***

Automatically manages memory by identifying and deallocating objects that are no longer referenced by the program,
preventing memory leaks.

***Native Method Interface (JNI)***

Allows Java code to interact with native applications and libraries written in other languages.

Native Method Libraries:

Libraries written in other languages that are loaded and used by native methods through JNI.

# ClassNotFound exception and NoClassDefFoundError

***ClassNotFoundException and NoClassDefFoundError***

Troubleshooting a ClassNotFoundException or NoClassDefFoundError in Java involves systematically checking the classpath
and the availability of required classes.

***ClassNotFoundException:***

This error indicates that the Java Virtual Machine (JVM) could not find the class definition at runtime when attempting
to load it dynamically (e.g., using Class.forName(), ClassLoader.loadClass()).

Verify Classpath: Ensure the JAR file or directory containing the missing class is correctly included in the runtime
classpath.

Command Line: Use the -cp or -classpath option with java.

```java
java -cp "path/to/your.jar:path/to/another.jar:."YourMainClass
```

Environment Variable: Set the CLASSPATH environment variable.

```bash
export CLASSPATH="path/to/your.jar:path/to/another.jar:."
```

Build Tools (Maven/Gradle): Confirm that the dependency is declared correctly and is included in the build output (e.g.,
target/lib or build/libs). Use mvn dependency:tree or ./gradlew dependencies to inspect the dependency tree.

Check for Typos: Double-check the fully qualified class name in the code for any spelling errors.

Dependency Conflicts: If using a build tool, investigate potential dependency conflicts where different versions of the
same library might be present, leading to the incorrect version being loaded.

Existence in JAR: Use jar -tf your.jar to verify that the missing class file (.class) actually exists within the
specified JAR.

Shaded/Relocated Classes: If using shaded JARs, ensure the class names have been correctly relocated if applicable.

***NoClassDefFoundError:***

This error signifies that the class definition was available at compile time but could not be found or initialized at
runtime. This often points to issues with dependencies or static initialization failures.

Classpath Verification (Same as ClassNotFoundException): Ensure all required JARs are present and accessible in the
runtime classpath. A NoClassDefFoundError can occur if a class's dependencies are missing from the classpath, even if
the class itself is found.

Static Initialization Failure: This is a common cause. If a class's static initializer block (static {}) throws an
exception, the JVM will fail to initialize the class, leading to NoClassDefFoundError when that class is subsequently
accessed. Examine the logs for an ExceptionInInitializerError that typically precedes the NoClassDefFoundError.

Corrupted or Incomplete JARs: Verify the integrity of your JAR files. Re-downloading or rebuilding them might resolve
issues with corrupted files.

Runtime vs. Compile-Time Mismatch: Ensure that the versions of libraries used at runtime are consistent with those used
during compilation. A mismatch can lead to missing methods or fields, causing the error.
Custom Class Loaders: If using custom class loaders, ensure they are correctly implemented and have access to all
necessary classes and their dependencies.

Exclusions in Build Tools: If using Maven or Gradle, check for any exclusions that might be inadvertently removing
required transitive dependencies.

***General Debugging Steps:***

Examine Stack Trace: The stack trace provides valuable information about the class and method where the error
originated.

Logging: Increase logging levels to gain more insight into class loading attempts and potential errors during static
initialization.

Clean Build: Perform a clean build (mvn clean install or ./gradlew clean build) to ensure no stale artifacts are causing
issues.

Simplify: Try to isolate the problem by creating a minimal reproducible example.

***Checked Exceptions:***

Compiler Enforcement:
Checked exceptions are exceptions that are "checked" by the Java compiler at compile time. This means that if a method
can potentially throw a checked exception, the compiler will require the programmer to either handle it using a
try-catch block or declare that the method throws the exception using the throws keyword in its signature. Failure to do
so will result in a compile-time error.

Purpose:
They are typically used for situations that are outside the immediate control of the program but are reasonably
anticipated and from which the program might be able to recover. Examples include IOException (e.g., file not found,
network issues) and SQLException (e.g., database connection problems).

Inheritance:
Checked exceptions are classes that inherit directly from the Exception class but do not inherit from RuntimeException.

***Unchecked Exceptions:***

Runtime Occurrence:
Unchecked exceptions are not checked by the compiler at compile time. They occur at runtime and are typically the result
of programming errors or logical flaws in the code.

No Mandatory Handling:
The compiler does not enforce handling of unchecked exceptions. While you can catch them, it is not mandatory, and
often, the appropriate action is to fix the underlying programming error rather than catching the exception.

Purpose:
They represent conditions that indicate a bug in the code, such as NullPointerException (accessing a null reference),
ArrayIndexOutOfBoundsException (accessing an array index out of bounds), or ArithmeticException (e.g., division by
zero).

Inheritance:
Unchecked exceptions are classes that inherit from the RuntimeException class, which itself inherits from Exception.

In summary:
Checked exceptions are for anticipated, recoverable external issues and require explicit handling or declaration.

Unchecked exceptions are for programming errors and do not require explicit handling, though addressing the root cause
is essential.

***Custom runtime exceptions***

To create custom runtime exceptions in Java, one must define a new class that extends the RuntimeException class. This
makes the custom exception an unchecked exception, meaning it does not require explicit handling with try-catch blocks
or throws declarations in method signatures, though it can still be caught if desired.

To use this custom runtime exception, one would throw an instance of it when an exceptional condition, which is
considered a programming error or an unrecoverable state, occurs.

# JDK Memory Model

***How is memory managed in JAVA?***

Memory management in Java is primarily handled automatically by the Java Virtual Machine (JVM), contrasting with manual
memory management in languages like C or C++. The JVM manages memory through a combination of heap memory, stack memory,
and Garbage Collection (GC).

- 1. Heap Memory:

This is a shared runtime data area where all objects and arrays are stored when they are created using the new keyword.

The JVM allocates memory from the heap for these objects, and their references are typically stored in the stack. The
heap is subject to Garbage Collection.

- 2. Stack Memory:

Each Java thread has its own dedicated stack, which is used for local variables, method parameters, and references to
objects on the heap.

When a method is called, a new frame is pushed onto the stack to hold its local variables and parameters.
When a method completes, its frame is popped from the stack, and the memory associated with it is automatically
deallocated. Stack memory operates on a Last-In-First-Out (LIFO) principle.

***Garbage Collection (GC)***

The JVM's Garbage Collector automatically identifies and reclaims memory occupied by objects in the heap that are no
longer referenced by any active part of the program.

This process prevents memory leaks and simplifies memory management for developers.
Common GC algorithms include Mark and Sweep, which involves marking reachable objects and then sweeping away the
unreachable ones to free up space.

Different garbage collectors exist (e.g., Parallel GC, Concurrent Mark Sweep GC, G1 GC) with varying performance
characteristics, and developers can configure the JVM to use a specific collector based on application needs.

In essence, the JVM automatically allocates memory for objects on the heap and manages their lifecycle, while stack
memory is used for method execution and local data, with the Garbage Collector handling the deallocation of unused
objects from the heap.

***What is young generation and old generation?***

a. Eden/Survivor Spaces and how the transition happens between the memory spaces
b. Minor and Major GC?

The young and old generations are divisions of memory in a garbage collector, where the young generation holds new,
short-lived objects and the old generation stores long-lived objects. The young generation is further split into Eden
space and two Survivor spaces (S0 and S1). When the Eden space fills up, a minor garbage collection (GC) cleans up
unreachable objects, copies surviving objects from Eden to a survivor space, and promotes aged objects to the old
generation.

***Young generation and old generation***

Young Generation: This is where newly created objects are initially allocated and "aged".

Eden Space: New objects are allocated here. The assumption is that most objects will have a short lifespan and will
become unreachable soon.

Survivor Spaces (S0 and S1): These two areas hold objects that have survived previous garbage collection cycles from the
Eden space.

Old Generation: Also known as the "tenured" generation, this area is for objects that have survived a number of young
generation garbage collections and are considered long-lived.

***Transition between memory spaces***

New objects are created: When a new object is created, it is first allocated in the Eden space.

Minor GC occurs: When the Eden space becomes full, a minor garbage collection is triggered.
Unreferenced (dead) objects are cleared from Eden.

Referenced (live) objects from Eden are moved to one of the survivor spaces (e.g., S0).

Objects are "aged": With each subsequent minor GC, objects that survive are copied from their current survivor space to
the other one, and their "age" is incremented.

Promotion to Old Generation: When an object reaches a certain age (based on its age counter), it is promoted from the
young generation to the Old Generation.

Major GC: Eventually, when the old generation fills up, a major garbage collection is triggered to clean up the
long-lived objects in that space.

# Garbage collection

Various Garbage Collection Types in Java and How to Specify Them:

***Serial Garbage Collector:***

Description: Uses a single thread for all garbage collection tasks, including young and old generation collection. It is
a "stop-the-world" collector, meaning all application threads are paused during GC.

Suitability: Best for client-side applications, single-processor machines, or applications with small
heap sizes where pauses are acceptable.

Specification:

```bash
    -XX:+UseSerialGC
```

***Parallel Garbage Collector (Throughput Collector)***

Description: The default GC in many JVM versions. It uses multiple threads for young generation collection and a single
thread for old generation collection. It prioritizes throughput, aiming to complete as much work as possible, even if it
means longer pause times.

Suitability: Ideal for applications that prioritize overall throughput, such as batch processing or data-intensive
applications, where longer pauses are tolerable.

Specification:

```bash
    -XX:+UseParallelGC
```

***Concurrent Mark and Sweep (CMS) Garbage Collector:***

Description: Aims to minimize "stop-the-world" pauses by performing most of its work concurrently with the application
threads. It focuses on collecting the old generation.

Suitability: Suitable for applications requiring low latency and responsiveness, where short pauses are crucial, even if
it means slightly lower throughput compared to Parallel GC.

Specification:

```bash
    -XX:+UseConcMarkSweepGC
```

***Garbage First (G1) Garbage Collector***

Description: A regionalized, generational collector designed to be a general-purpose solution. It divides the heap into
regions and collects the regions with the most garbage first ("garbage first"). It aims for a balance between throughput
and pause times.

Suitability: A good choice for a wide range of applications, especially those with large heaps and a need for
predictable pause times. It is the default in newer Java versions.

Specification:

```bash
    -XX:+UseG1GC
```

***Z Garbage Collector (ZGC)***

Description: A highly scalable, low-latency garbage collector designed for applications with very large heaps (
terabytes) and extremely low pause time requirements (milliseconds). It performs most of its work concurrently.

Suitability: Best for high-scale, low-latency applications with massive heaps.

Specification:

```bash
    -XX:+UseZGC
```

***Shenandoah Garbage Collector***

Description: Another low-pause-time collector, similar to ZGC, but with a different implementation approach. It aims to
reduce pause times by performing most of the GC work concurrently with the application.

Suitability: Ideal for applications requiring consistently low pause times, even with large heaps.
Specification:

```bash
    -XX:+UseShenandoahGC
```

How to Specify a Garbage Collector:
You can specify the desired garbage collector using JVM arguments when launching your Java application. The arguments
are passed using the -XX: prefix. For example, to use the G1 garbage collector:

```bash
java -XX:+UseG1GC -jar YourApplication.jar
```

***CMS & G1 garbage collection and what does String Deduplication means?***

The Concurrent Mark Sweep (CMS) and Garbage-First (G1) are Java garbage collectors, with G1 being the intended successor
to CMS, offering better pause time predictability and memory management. String Deduplication is an optimization feature
available with G1 and other modern collectors that saves memory by consolidating identical string values to a single
internal character array.

***CMS vs. G1 Garbage Collector***

The primary differences lie in their approach to memory management, fragmentation handling, and pause time
predictability.

Feature Concurrent Mark Sweep (CMS)    Garbage-First (G1)
Memory Management Uses a traditional generational heap structure (Young, Old) with fixed-size generations. Divides the
heap into many equal-sized regions, dynamically assigning them roles (Eden, Survivor, Old).
Fragmentation Does not perform compaction during its main concurrent phases, leading to potential memory fragmentation
that may trigger a lengthy "stop-the-world" (STW) full GC. Employs a mark-and-compact approach, evacuating (copying)
live objects to new regions during collection, which eliminates fragmentation on the go.
Pause Times Designed for low pause times but can experience long, unpredictable pauses if a Full GC is triggered due to
fragmentation or allocation failures. Aims for predictable pauses by allowing users to set a pause time goal (e.g.,
MaxGCPauseMillis). It prioritizes collecting regions with the most garbage first to meet this goal.
Concurrency Performs most of its work concurrently with the application threads, minimizing application pauses. Also
runs concurrently and in parallel, but with a more refined approach that allows incremental processing of the old
generation.
Status Deprecated in JDK 9 and removed in later versions. The default garbage collector since JDK 9.

# Volatile

a. Does declaring a variable as volatile ensures thread safety? If not then what to use?

Use the volatile keyword when a variable's value can change unexpectedly, such as in a multi-threaded program where one
thread reads the variable while another writes to it, or in embedded systems where a hardware interrupt can change a
variable's value. Its purpose is to prevent the compiler from optimizing away reads and writes, ensuring that every read
comes directly from main memory, not a cached value, and that every write is immediately flushed to memory.

***Use cases for volatile***

Multi-threaded programming:
Flags and status indicators: For a simple flag that controls a thread's execution or indicates its status (e.g.,
is_running, has_finished), volatile ensures all threads see the most up-to-date value.

Shared variables:
When a variable is shared and modified by multiple threads, volatile guarantees that changes made by one thread are
immediately visible to all other threads.

Embedded systems and hardware interaction:
Memory-mapped I/O: To access memory locations that represent hardware peripherals, volatile is essential to ensure the
program reads the current state from the device, not an optimized, stale value.
Interrupts: It's used for variables that can be modified by an interrupt service routine, guaranteeing the main program
reads the correct, updated value after an interrupt occurs.

Preventing compiler optimization:
The keyword tells the compiler not to apply certain optimizations on the variable because its value can change at any
time, regardless of what the code itself does. This prevents the compiler from optimizing out reads or reordering
accesses, which is crucial for correctness in these scenarios.

***Important considerations***

volatile provides visibility, not atomicity:
It ensures changes are visible across threads, but it does not guarantee that operations are atomic. For example, an i++
operation is not atomic, and volatile alone won't make it thread-safe. For atomic operations on compound actions, you
must use other synchronization mechanisms like synchronized blocks or atomic classes.

Local variables are safe:
There is no need to declare local variables as volatile, as they are not visible to other threads and are not subject to
the same compiler optimizations that require this keyword.

# Atomic variables

a. Which algorithm is used to identify the change? (CAS- Compare & Swap)

Use atomic variables for simple, individual operations on shared variables in multi-threaded environments to ensure
thread safety without the overhead of locks. They are ideal for tasks like incrementing counters, setting a value, or
performing a compare-and-swap operation where a single, uninterruptible update is needed. Use traditional locks for
complex, multi-step operations, as atomic variables are not designed for them.

When to use atomic variables
Updating single variables from multiple threads: This is the primary use case. Without atomics, operations like ++ are
not truly atomic, leading to race conditions where updates can be lost.

Improving performance: Atomic variables use hardware-level atomic operations, which are often more efficient than
traditional locks (like synchronized blocks or ReentrantLock) for simple updates.

Avoiding locks: If you need thread safety for a simple operation, atomic variables provide a lock-free way to achieve
it, preventing potential performance bottlenecks associated with locks.

Ensuring data consistency: They guarantee that operations on the variable are performed as a single, indivisible unit,
preventing other threads from interfering during the operation.
When to use other tools instead

Complex, multi-step operations: If an operation involves multiple reads and writes, use traditional locks instead of
atomic variables. Trying to manage complex logic with atomic variables can lead to incorrect results.

Need for more than one variable at a time: Atomic variables work on a single variable. For operations that require
multiple variables to be updated together in a consistent way, you need a lock that can cover all the variables.

Read-heavy scenarios with occasional writes: For variables that are read much more often than they are written, a
volatile keyword might be a more performant choice, especially for visibility guarantees. However, volatile does not
guarantee atomicity for compound operations like ++.

***CAS- Compare & Swap***

The mechanism used in Java's atomic variables to identify a change is the Compare-and-Swap (CAS) algorithm itself. There
isn't a separate, specific "CASE" algorithm; rather, "CASE" appears to be an alternative, less common way of referring
to the CAS principle.

The Compare-and-Swap (CAS) Algorithm:
The CAS algorithm is a non-blocking synchronization primitive that operates using three main parameters:

Memory Location (V): The variable's memory address that a thread wants to modify.

Expected Old Value (A): The value the thread expects to find currently at memory location V (the value the thread last
read).

New Value (B): The value the thread wants to write to memory location V.

The operation works as follows:
The hardware atomically compares the current value at V with the expected value A.
If they match, the value at V is atomically swapped with the new value B, and the operation returns true (success). This
means no other thread modified the variable in the interim.
If they do not match, the value at V is left unchanged, and the operation returns false (failure). This signals that
another thread has modified the variable, and the current thread must usually retry the operation by re-reading the
current value.
Java's atomic classes, such as AtomicInteger, AtomicLong, and AtomicReference, use methods like compareAndSet() which
internally leverage the CAS operation supported by modern processors (e.g., LOCK CMPXCHG instruction on x86
architectures). This allows for efficient, lock-free, thread-safe operations.

# Marker interface

A marker interface is an interface that contains no methods or fields, used to "mark" a class with metadata so that
other code can recognize it and react accordingly at runtime. For example, the java.io.Serializable interface is a
marker interface that indicates a class can be serialized. You can absolutely declare your own marker interface by
simply creating an empty interface, and then any class can implement it to be "tagged".

***What a marker interface is***

A tag for metadata: It serves as a tag or "marker" to provide information about a class, often for the Java Virtual
Machine (JVM), a framework, or other components.

No methods or fields: The defining characteristic is that it has no methods or constants, unlike regular interfaces
which define behavior.

Runtime information: Other code can check if an object implements the marker interface and then adapt its behavior. A
common way to do this is using the instanceof keyword.

Examples: Standard library examples include Serializable, Cloneable, and Remote. A custom example could be an
AdminAccess interface to restrict certain operations to classes that implement it.

***How to declare your own marker interface***

Define an empty interface: Create an interface with no methods or fields. For example:

```java
public interface MyMarkerInterface {
}

```

Implement the interface: A class can then implement this interface. The interface name itself provides the meaning. For
example:

```java
public class MyClass implements MyMarkerInterface {
    // Class members
}

```

Use instanceof to check: Other code can now check if an object is of your marker type. For instance, if you have a
process method that needs to do something special for objects that are instances of MyMarkerInterface:

```java
public void process(Object obj) {
    if (obj instanceof MyMarkerInterface) {
        // Perform special processing
    } else {
        // Perform default processing
    }
}

```

# Abstract class

a. Can an abstract class have a constructor? When is that called?

Yes, an abstract class in Java can have constructors.

When is it called?

The constructor of an abstract class is called when an instance of a concrete subclass of that abstract class is
created.

Explanation:

While you cannot directly instantiate an abstract class (meaning you cannot create an object of the abstract class
itself), its constructors serve to initialize the fields and establish the initial state of the abstract class's part of
the object. When a concrete subclass is instantiated, its constructor implicitly or explicitly calls a constructor of
its superclass (which might be an abstract class) using super(). This ensures that the inherited members of the abstract
class are properly initialized before the subclass's own initialization logic is executed.

```java
abstract class Vehicle {
    String brand;

    // Constructor for the abstract class
    public Vehicle(String brand) {
        this.brand = brand;
        System.out.println("Vehicle constructor called. Brand: " + brand);
    }
}

class Car extends Vehicle {
    String model;

    public Car(String brand, String model) {
        super(brand); // Calls the constructor of the abstract class Vehicle
        this.model = model;
        System.out.println("Car constructor called. Model: " + model);
    }
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car("Toyota", "Camry");
        // Output:
        // Vehicle constructor called. Brand: Toyota
        // Car constructor called. Model: Camry
    }
}
```

# Init and static block

In Java, static blocks, instance initializer blocks (often referred to as init blocks), and constructors serve distinct
purposes and have a specific order of execution.

1. Static Block:

A static block is used to initialize static members of a class.
It is executed only once when the class is loaded into the Java Virtual Machine (JVM), even before the main method is
called or any object of the class is created.
static blocks are useful for performing one-time setup tasks or initializing complex static data structures.

Example:

```java
class MyClass {
    static {
        System.out.println("Static block executed.");
        // Initialize static variables here
    }
    // ...
}

```

2. Instance Initializer Block (init block):

An instance initializer block is used to initialize instance members of a class.
It is executed every time an object of the class is created, before the constructor is called.
Instance initializer blocks can be used to perform common initialization logic that needs to be executed regardless of
which constructor is invoked.

Example:

```java

class MyClass {
    {
        System.out.println("Instance initializer block executed.");
        // Initialize instance variables here
    }
    // ...
}
```

# Constructor

A constructor is a special method used to create and initialize new objects of a class.
It is executed every time an object is instantiated using the new keyword.
Constructors can take arguments and are responsible for setting the initial state of an object.

Example:

```java
class MyClass {
    MyClass() {
        System.out.println("Constructor executed.");
        // Initialize object state here
    }
    // ...
}
```

Order of Execution:

When a class is loaded and an object is created, the order of execution is as follows:

Static blocks: All static blocks in the class are executed in the order they appear in the source code.
This happens only once when the class is loaded.

Instance initializer blocks: When an object is created, all instance initializer blocks are executed in the order they
appear in the source code.

Constructor: Finally, the constructor corresponding to the object creation is executed.

In summary:
static blocks are for class-level initialization, executed once.
Instance initializer blocks are for object-level initialization, executed before the constructor for each object.
Constructors are for object creation and specific initialization based on parameters.

# String Deduplication

String deduplication is a memory optimization technique that reduces the memory footprint of String objects by
identifying duplicate strings and making them share the same underlying character array.

**Mechanism**: A large percentage of heap memory in typical Java applications can be consumed by duplicate String
objects. When this feature is enabled (using the -XX:+UseStringDeduplication flag, typically with G1GC or other modern
collectors in recent Java versions), the garbage collector works in the background to find strings with identical
content.

**Process**: During a GC cycle, eligible long-lived strings (past a certain age threshold) are inspected. If two or more
strings have the same value, the JVM modifies them to all point to a single, shared character array. The now-unused
duplicate arrays are then garbage collected, freeing up memory.

**Benefit**: This process can significantly reduce the memory pressure on the heap, potentially by around 10% on
average, leading to fewer garbage collection cycles and improved overall application performance, especially in
applications that handle large amounts of data or cache objects.

# Heap Dump

a. How to take heap dump and analyse the same?

Taking and analyzing a heap dump is crucial for diagnosing memory-related issues like leaks in Java applications.

1. Taking a Heap Dump:

Several methods exist to capture a heap dump: jmap command (Manual).

```bash
    jmap -dump:format=b,file=heapdump.hprof <pid>
```

Replace <pid> with the process ID of your Java application.

JVM Arguments (Automatic on OOM): Configure the JVM to automatically generate a heap dump when an OutOfMemoryError
occurs.

```bash
    -XX:+HeapDumpOnOutOfOMError -XX:HeapDumpPath=/path/to/dump/directory
```

**JMX Tools (e.g., JConsole, JVisualVM)**: Connect to your running Java application and trigger a heap dump through the
graphical interface.

**IDE Profilers (e.g., IntelliJ IDEA, Android Studio)**: These tools often provide integrated options to capture heap
dumps of applications running within the IDE.

2. Analyzing a Heap Dump:
   Specialized tools are required to analyze the generated .hprof file:
   Eclipse Memory Analyzer Tool (MAT): A powerful and widely used tool for deep analysis.
   Open MAT and select "File" > "Open Heap Dump".
   Choose the .hprof file.
   MAT provides various views and reports, including:
   Leak Suspects Report: Identifies potential memory leaks.
   Histogram: Shows object counts and sizes by class.
   Dominator Tree: Visualizes the largest objects and their retained sizes.
   Object Query Language (OQL): Allows querying objects within the heap.
   Java VisualVM: Offers basic heap dump analysis capabilities, including browsing objects and their references.
   JProfiler: A commercial profiling tool with comprehensive heap analysis features.
   HeapHero: A cloud-based or on-premise tool that uses machine learning to detect memory leaks.

***Key Areas to Focus on During Analysis***

Large Objects: Identify classes or objects consuming significant memory.
Growing Objects: If comparing multiple dumps, look for objects whose instance count or size consistently increases.
Object References: Understand what objects are holding references to other objects, preventing garbage collection.
Leak Suspects: Investigate the reports generated by analysis tools to pinpoint potential memory leaks.

***Concept of String Pool can be touched in order to judge the memory allocation for a String Object.***

The Java String Pool, also known as the *String Intern Pool* or *String Constant Pool*, is a special area within the
Java heap memory where string literals are stored. This mechanism is crucial for optimizing memory allocation and
performance when dealing with String objects in Java.

# String pool

a. How the String Pool Impacts Memory Allocation:**

**String Literals**: When a String is created using a literal (e.g., String s1 = "hello";), the JVM first checks the
String Pool.
If an identical String object already exists in the pool, the JVM returns a reference to that existing object, avoiding
the creation of a new object and thus saving memory.
If the String literal is not found in the pool, a new String object is created, placed in the pool, and a reference to
it is returned.

**new Keyword**: When a String is created using the new keyword (e.g., String s2 = new String("world");), a new String
object is always created in the heap, outside the String Pool, even if an identical String literal already exists in the
pool.
intern() Method: The intern() method can be used to explicitly add a String to the String Pool (if it's not already
present) and return a reference to the pooled instance. This can be beneficial for optimizing memory usage when dealing
with Strings created using the new keyword that are frequently compared or used as keys in collections.

Example:

```Java

String s1 = "java"; // "java" is added to the String Pool (if not already present)
String s2 = "java"; // s2 refers to the same "java" object in the String Pool as s1
String s3 = new String("java"); // A new "java" object is created in the heap, outside the pool
String s4 = s3.intern(); // s4 refers to the "java" object in the String Pool
```

In this example, s1 and s2 reference the same object in the String Pool, while s3 references a distinct object in the
heap. s4, after calling intern(), also references the same object in the String Pool as s1 and s2. This demonstrates how
the String Pool can lead to memory optimization by reusing immutable String objects.

# Serialization and Externalization

1. What does serialization means and why is it required?

a. How can you achieve serialization?
b. What are compatible and non-compatible changes for a serialized object?

Serialization or marshaling is the process of converting object state into a format that can be transmitted or stored.
The serialization changes the object state into series of bits. The object state could be reconstructed later in the
opposite process, called deserialization or unmarshalling .

a. (How can you achieve serialization?)

Serialization in Java, the process of converting an object's state into a byte stream, can be achieved through the
following steps: Implement the Serializable interface.
The class of the object you intend to serialize must implement the java.io.Serializable interface. This is a marker
interface, meaning it has no methods, but it signals to the Java Virtual Machine (JVM) that instances of this class can
be serialized.

```Java

import java.io.Serializable;

public class MyObject implements Serializable {
    private String name;
    private int value;

    // Constructor, getters, setters, etc.
}
```

Create an ObjectOutputStream.
An ObjectOutputStream is used to write Java objects to an output stream (like a FileOutputStream to a file, or a
ByteArrayOutputStream to a byte array).

```Java

import java.io.FileOutputStream;
import java.io.ObjectOutputStream;

// ...
FileOutputStream fileOut = new FileOutputStream("object.ser");
        ObjectOutputStream out = new ObjectOutputStream(fileOut);
```

Write the object using writeObject().
Call the writeObject() method of the ObjectOutputStream, passing the object you want to serialize as an argument.

```Java

// ...
MyObject myObject = new MyObject("Example", 123);
    out.

writeObject(myObject);
```

Close the streams.
It is crucial to close both the ObjectOutputStream and the underlying output stream (e.g., FileOutputStream) to release
resources and ensure all data is written.

```Java

// ...
    out.close();
    fileOut.

close();
```

Important Considerations:
transient keyword: Use the transient keyword to mark fields that should not be serialized. Their values will be ignored
during serialization.
serialVersionUID: It is recommended to declare a static final long serialVersionUID in your Serializable classes to
control versioning and ensure compatibility when deserializing objects saved with different versions of the class.
Security: Be aware of potential security risks associated with serialization, as malicious data streams could be crafted
to exploit vulnerabilities during deserialization.
Externalizable interface: For more fine-grained control over the serialization process, you can implement the
Externalizable interface, which requires you to implement writeExternal() and readExternal() methods for custom
serialization logic.

***b.***

When dealing with Java serialization, changes to a class can be categorized as compatible or non-compatible, determining
whether a serialized object can be successfully deserialized by a different version of the same class. The
serialVersionUID plays a crucial role in this process.
Compatible Changes:
Compatible changes allow a newer version of a class to deserialize objects serialized by an older version, and
vice-versa, without throwing an InvalidClassException. These changes generally do not fundamentally alter the structure
or meaning of the class's serialized state.
Adding new fields: New fields in the class will be initialized to their default values when deserializing an object from
an older stream that lacks these fields.
Adding new methods: Adding methods, including writeReplace or readResolve (if their behavior remains compatible with
older versions), does not affect the serialized form.
Changing a field from static to non-static or vice versa: This change is compatible as static fields are not part of the
serialized state.
Changing a field from transient to non-transient or vice versa: Transient fields are ignored during serialization, so
this change does not affect compatibility.
Adding or removing classes in the class hierarchy (with careful handling): While complex, this can be compatible if the
serialization mechanism correctly handles missing or added classes in the hierarchy.
Non-Compatible Changes:
Non-compatible changes fundamentally alter the serialized form of an object, making it impossible to deserialize with a
different version of the class without explicit handling or a change in the serialVersionUID. These changes will
typically result in an InvalidClassException.
Changing the type of a non-static, non-transient field: If a field's type is changed, the serialized data for that field
will not match the expected type during deserialization.
Removing a non-static, non-transient field: The deserializer will expect a field that is no longer present in the
stream.
Changing the class hierarchy in a way that breaks serialization: For example, changing a superclass or implementing a
different serialization mechanism like Externalizable instead of Serializable.
Changing the serialVersionUID: This explicitly signals that the class versions are incompatible, leading to an
InvalidClassException during deserialization if the IDs don't match.
Importance of serialVersionUID:
To ensure compatibility, it is highly recommended to explicitly declare a static final long serialVersionUID in
serializable classes. If not declared, the Java runtime will generate one based on the class's structure, which can
change with minor modifications, leading to unexpected InvalidClassExceptions. By maintaining a consistent
serialVersionUID across compatible versions, you explicitly tell the serialization mechanism that the class versions are
compatible despite minor structural changes.

***2. What impact does Final, Transient & Static keywords have on member variables during serialization/deserialization?***

The final, transient, and static keywords in Java have distinct impacts on member variables during serialization and
deserialization:

1. transient keyword:
   Impact: Prevents a member variable from being serialized.
   Serialization: When an object is serialized, transient fields are skipped and not written to the output stream.
   Deserialization: Upon deserialization, transient fields are initialized to their default values (e.g., 0 for int,
   false for boolean, null for object references).

2. static keyword:
   Impact: static members belong to the class, not to individual objects, and are therefore not part of an object's
   serializable state.

Serialization: static fields are not included in the serialized form of an object.

Deserialization: The static field retains its value from the current class definition in memory, regardless of the
serialized object's state. Any changes to a static field after serialization but before deserialization will be
reflected in the deserialized object.

3. final keyword:
   Impact: final variables are directly serialized by their values.
   Serialization: The value of a final field is serialized along with other non-transient instance variables.
   Deserialization: The final field's value is restored from the serialized data.
   Combinations:
   transient final: Declaring a final variable as transient effectively negates the transient keyword's purpose for that
   specific variable. Since final variables are serialized by value, marking them transient will not prevent their value
   from being stored in the serialized stream.
   transient static: Marking a static variable as transient has no practical impact on serialization, as static fields
   are already not part of the object's serializable state.
   In summary:
   Use transient to explicitly exclude instance variables from serialization.
   static variables are inherently excluded from object serialization.
   final variables are serialized by value, and transient has no effect on them.

***3. What will happen if one the member of class does not implement Serializable interface?***

If a class in Java implements the Serializable interface, but one of its non-transient member variables is an object of
a class that does not implement Serializable, attempting to serialize an instance of the outer class will result in a
NotSerializableException.
Here's a breakdown:
Serializable Interface: This is a marker interface that signals to the Java Virtual Machine (JVM) that objects of the
implementing class can be converted into a stream of bytes (serialized) and later reconstructed (deserialized).
Object Graph: When an object is serialized, the JVM traverses its entire "object graph," which includes all the objects
it directly or indirectly references. For successful serialization, every object in this graph (unless marked transient)
must also be serializable.
The Exception: If the JVM encounters a non-transient member variable that references an object of a class not
implementing Serializable, it cannot serialize that part of the object graph. Consequently, it throws a
java.io.NotSerializableException, indicating which class is the culprit.
How to handle this:
Make the member class serializable: If possible and appropriate, modify the class of the non-serializable member
variable to implement Serializable.
Mark the member as transient: If the member variable does not need to be persisted as part of the serialized object,
declare it with the transient keyword. This tells the JVM to skip this field during serialization.
Custom serialization: For more complex scenarios, you can implement custom serialization logic using writeObject and
readObject methods within the serializable class. This allows you to manually handle the serialization and
deserialization of non-serializable members, for example, by converting them to a serializable format or reconstructing
them during deserialization.

***4. What is the role of serialVersionUID?***

The serialVersionUID in Java plays a critical role in the serialization and deserialization process, specifically for
classes that implement the java.io.Serializable interface. Its primary function is to act as a version control
mechanism, ensuring compatibility between a serialized object and the class definition used for deserialization.
Here's a breakdown of its role:
Ensuring Compatibility: When an object is serialized, its serialVersionUID is stored along with the object's data.
During deserialization, the JVM compares the serialVersionUID of the incoming serialized object with the
serialVersionUID of the corresponding class definition loaded in the current environment. If these IDs do not match, an
InvalidClassException is thrown, preventing potential data corruption or unexpected behavior that could arise from
loading an object into an incompatible class structure.
Version Control: The serialVersionUID allows developers to explicitly manage the version of a serializable class. By
declaring a private static final long serialVersionUID field, you can control when a class is considered compatible or
incompatible for serialization. If you make changes to a class that you deem incompatible with older serialized
versions (e.g., major structural changes, removal of fields), you should update the serialVersionUID to a new value.
This will prevent older serialized objects from being deserialized by the newer class version, forcing users to update
their data or code. Conversely, if you make minor, compatible changes (e.g., adding a new field that can be initialized
to a default value), you can keep the same serialVersionUID to maintain backward compatibility.
Preventing Default Generation Issues: If a serialVersionUID is not explicitly declared, the Java Virtual Machine (JVM)
automatically generates one based on various class details. This automatically generated ID can be highly sensitive to
compiler implementations and minor class changes, potentially leading to InvalidClassException even for seemingly
innocuous modifications. Explicitly declaring serialVersionUID eliminates this ambiguity and provides predictable
versioning behavior.
In essence, serialVersionUID acts as a safeguard, ensuring that serialized objects can only be deserialized by
compatible versions of their respective classes, thereby maintaining data integrity and preventing runtime errors.

*** 5. What will happen if have a collection member variable in a class to be serialized?***

If a class in Java implements the Serializable interface and contains a collection as a member variable, the behavior
during serialization depends on whether the concrete implementation of that collection and its elements are also
serializable.
Here's a breakdown:
Standard Collections (e.g., ArrayList, HashMap): Most standard Java Collection implementations (like ArrayList,
LinkedList, HashSet, HashMap) already implement the Serializable interface. If you use these standard implementations,
the collection and its elements will be serialized automatically, provided that the elements themselves are also
serializable.

```Java

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

class MyClass implements Serializable {
    private List<String> myStrings; // ArrayList implements Serializable

    public MyClass() {
        myStrings = new ArrayList<>();
        myStrings.add("Hello");
        myStrings.add("World");
    }
}
```

Custom Collections or Non-Serializable Elements:
Non-Serializable Collection Implementation: If you use a custom Collection implementation that does not implement
Serializable, a NotSerializableException will be thrown during serialization.
Non-Serializable Elements: If the collection itself is serializable (e.g., ArrayList), but the objects stored within the
collection do not implement Serializable, a NotSerializableException will still be thrown when attempting to serialize
the MyClass object.

```Java

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

class NonSerializableElement {
    // This class does NOT implement Serializable
    private String data;

    public NonSerializableElement(String data) {
        this.data = data;
    }
}

class AnotherClass implements Serializable {
    private List<NonSerializableElement> elements; // Will cause NotSerializableException

    public AnotherClass() {
        elements = new ArrayList<>();
        elements.add(new NonSerializableElement("Item 1"));
    }
}
```

Handling Non-Serializable Members with transient: If a collection or its elements cannot or should not be serialized,
you can mark the collection member variable with the transient keyword. This will prevent that specific field from being
included in the serialization process. When deserialized, transient fields will be initialized to their default values (
e.g., null for object references, 0 for int).

```Java

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

class AnotherClassWithTransient implements Serializable {
    private transient List<NonSerializableElement> elements; // Will NOT be serialized

    public AnotherClassWithTransient() {
        elements = new ArrayList<>();
        elements.add(new NonSerializableElement("Item 1"));
    }
}
```

In summary, for a class with a collection member variable to be successfully serialized, both the concrete collection
implementation and all its contained elements must implement the Serializable interface, unless the collection itself is
marked as transient.

***6. Does constructor of class gets called during deserialization?***

During deserialization in Java, the constructors of a Serializable class are generally not called.
Instead of invoking constructors, Java's serialization mechanism directly reconstructs the object's state by allocating
memory for the object and then populating its fields from the serialized byte stream. This process bypasses the usual
object creation flow, including constructor execution and field initializers.
Exception:
The only scenario where a constructor might be called during deserialization is if the class being deserialized has a
non-serializable superclass. In this case, the no-argument constructor of the first non-serializable superclass in the
hierarchy will be invoked to properly initialize the state inherited from that non-serializable superclass.
In summary:
For a Serializable class itself, its constructors are bypassed during deserialization.
For a Serializable class with a non-serializable superclass, the no-argument constructor of that non-serializable
superclass will be called.

***7. How you can avoid Deserialization process creating another instance of Singleton class?***

a. readResolve()

To prevent deserialization from creating a new instance of a Singleton class in Java, you must implement the
readResolve() method within the Singleton class.
Here's how it works:
Serialization and Deserialization: When a Singleton class implements Serializable, it can be written to an output
stream (serialized) and later read back from an input stream (deserialized). By default, deserialization creates a new
object instance.
The readResolve() Method: The readResolve() method is a special method that Java's object serialization mechanism looks
for during deserialization. If found, this method is invoked after the object has been initially deserialized but before
it is returned to the caller.
Returning the Existing Instance: Inside the readResolve() method, you should return the existing instance of your
Singleton class. This ensures that instead of the newly deserialized object, the original, single instance is always
returned.
Example Implementation:

```Java

import java.io.Serializable;

public class MySingleton implements Serializable {

    private static final MySingleton INSTANCE = new MySingleton();

    private MySingleton() {
        // Private constructor to prevent direct instantiation
    }

    public static MySingleton getInstance() {
        return INSTANCE;
    }

    // This method is crucial for preventing new instances during deserialization
    private Object readResolve() {
        return INSTANCE;
    }

    // Other methods and fields of your Singleton class
    public void doSomething() {
        System.out.println("Singleton instance performing an action.");
    }
}
```

By implementing readResolve() as shown, you guarantee that even after serialization and deserialization, the Singleton
pattern's core principle of having only one instance is maintained.

# Serializable and Externalizable

In Java, both Serializable and Externalizable interfaces are used for object serialization, but they offer different
levels of control over the process.

***Serializable Interface:***

Marker Interface:
Serializable is a marker interface, meaning it contains no methods. Implementing it simply signals to the Java Virtual
Machine (JVM) that instances of the class can be serialized using the default serialization mechanism.

Automatic Serialization:
The JVM handles the entire serialization and deserialization process automatically, using reflection to save and restore
the object's state.

Ease of Use:
It is simple to implement, requiring only the declaration of implements Serializable on the class.

Potential Performance Overhead:
The default serialization mechanism can be less efficient than custom serialization, especially for large or complex
objects, due to the use of reflection and saving of all non-transient fields.

No-Arg Constructor Not Required:
The default serialization mechanism does not require a public no-argument constructor.

***Externalizable Interface:***

Custom Control:
Externalizable provides complete control over the serialization and deserialization process.

Methods to Implement:
It requires the implementation of two methods:

```java
void writeExternal(ObjectOutput out) throws IOException

void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
```

Manual Serialization Logic:
The developer is responsible for explicitly writing and reading the object's state within these methods. This allows for
selective serialization of fields, custom data formats, and optimization.

Improved Performance:
By controlling the serialization logic, developers can often achieve better performance and smaller serialized object
sizes compared to default serialization.

Public No-Arg Constructor Required:
Classes implementing Externalizable must have a public no-argument constructor, as the deserialization process uses it
to create an instance of the object before calling readExternal().

Inheritance Consideration:
When implementing Externalizable, the class is responsible for explicitly handling the serialization of its superclass's
state if necessary.

# Checked and Unchecked Exceptions

a. How you will create runtime exceptions?
b. Explanation with real time scenarios to support the use of both types of exceptions.

In Java, exceptions are categorized into two main types: checked exceptions and unchecked exceptions. 
The key distinction lies in how they are handled by the compiler and the programmer.
